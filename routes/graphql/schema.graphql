"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

type User {
    id: ID!
    name: String!
    email: String! @canAccessUser
    is_admin: Boolean! @canAccessAdmin
    created_at: DateTime! @canAccessUser
    updated_at: DateTime! @canAccessUser

    carts: [Cart!]! @canAccessUser @hasMany
    orderCustomers: [Order!]! @canAccessUser @hasMany
    orderRecipients: [Order!]! @canAccessUser @hasMany
}

type Category {
    id: ID!
    name: String!
    created_at: DateTime!
    updated_at: DateTime!

    dishes: [Dish!]! @hasMany
}

type Dish {
    id: ID!
    name: String!
    ingredients: String!
    weight: String!
    created_at: DateTime!
    updated_at: DateTime!

    category: Category! @belongsTo
    menus: [Menu!]! @hasMany
    orderItems: [OrderItem!]! @hasMany
}

type Menu {
    id: ID!
    price: Int!
    actual_at: Date!
    created_at: DateTime!
    updated_at: DateTime!

    dish: Dish! @belongsTo
    cart: Cart! @hasMany
}

type Cart {
    id: ID!
    price: Int!
    count: Int!
    created_at: DateTime!
    updated_at: DateTime!

    user: User! @belongsTo
    menu: Menu! @belongsTo
}

type Order {
    id: ID!
    created_at: DateTime!
    updated_at: DateTime!

    customer: User! @belongsTo
    recipient: User @belongsTo
    orderItems: [OrderItem!]! @hasMany
}

type OrderItem {
    id: ID!
    price: Int!
    count: Int!
    created_at: DateTime!
    updated_at: DateTime!

    order: Order! @belongsTo
    dish: Dish! @belongsTo
}

type Query {
    me: User @auth
}

extend type Query @guard {
    users: [User!]! @all @softDeletes
    usersPagination: [User!]! @paginate @softDeletes
    user(id: ID @eq): User @find @softDeletes

    categories: [Category!]! @all @softDeletes
    categoriesPagination: [Category!]! @paginate @softDeletes
    category(id: ID @eq): Category @find @softDeletes

    dishes: [Dish!]! @all @softDeletes
    dishesPagination: [Dish!]! @paginate @softDeletes
    dish(id: ID @eq): Dish @find @softDeletes

    menus: [Menu!]! @all(scopes: ["actual"]) @softDeletes
    menusPagination: [Menu!]! @paginate(scopes: ["actual"]) @softDeletes
    menu(id: ID @eq): Menu @find(scopes: ["actual"]) @softDeletes

    carts: [Cart!]! @all(scopes: ["accessUser"]) @softDeletes
    cartsPagination: [Cart!]! @paginate(scopes: ["accessUser"]) @softDeletes
    cart(id: ID @eq): Cart @can(ability: "view", injectArgs: true) @find @softDeletes

    orders: [Order!]! @all(scopes: ["accessUser"]) @softDeletes
    ordersPagination: [Order!]! @paginate(scopes: ["accessUser"]) @softDeletes
    order(id: ID @eq): Order @can(ability: "view", injectArgs: true) @find @softDeletes

    orderItems: [OrderItem!]! @all(scopes: ["accessUser"]) @softDeletes
    orderItemsPagination: [OrderItem!]! @paginate(scopes: ["accessUser"]) @softDeletes
    orderItem(id: ID @eq): OrderItem @can(ability: "view", injectArgs: true) @find @softDeletes
}

type Mutation {
#    "Log in to a new session and get the user."
#    login(email: String!, password: String!): User!
#    "Log out from the current session, showing the user one last time."
#    logout: User @guard

    createUser(
        name: String!
        email: String! @rules(apply: ["email", "unique:users"])
        password: String! @rules(apply: ["min:8"]) @hash
    ): User! @create
    updateUser(
        id: ID!
        name: String
        email: String
        password: String @rules(apply: ["min:8"]) @hash
    ): User @can(ability: "update", injectArgs: true) @update
    upsertUser(
        id: ID!
        name: String!
        email: String!
        password: String! @rules(apply: ["min:8"]) @hash
    ): User @can(ability: "upsert", injectArgs: true) @upsert
    deleteUser(id: ID!): User @can(ability: "delete") @delete
    restoreUser(id: ID!): User @can(ability: "restore") @restore
    forceDeleteUser(id: ID!): User @can(ability: "forceDelete") @forceDelete


    createCategory(
        name: String! @rules(apply: ["unique:categories"])
    ): Category! @can(ability: "create") @create
    updateCategory(
        id: ID!
        name: String @rules(apply: ["unique:categories"])
    ): Category @can(ability: "update") @update
    upsertCategory(
        id: ID!
        name: String! @rules(apply: ["unique:categories"])
    ): Category @can(ability: "upsert") @upsert
    deleteCategory(id: ID!): Category @can(ability: "delete") @delete
    restoreCategory(id: ID!): Category @can(ability: "restore") @restore
    forceDeleteCategoryCategory(id: ID!): Category @can(ability: "forceDelete") @forceDelete

    createDish(
        category_id: ID!
        name: String! @rules(apply: ["unique:dishes"])
        ingredients: String!
        weight: String!
    ): Dish! @can(ability: "create") @create
    updateDish(
        id: ID!
        category_id: ID
        name: String @rules(apply: ["unique:dishes"])
        ingredients: String
        weight: String
    ): Dish @can(ability: "update") @update
    upsertDish(
        id: ID!
        category_id: ID!
        name: String! @rules(apply: ["unique:dishes"])
        ingredients: String!
        weight: String!
    ): Dish @can(ability: "upsert") @upsert
    deleteDish(id: ID!): Dish @can(ability: "delete") @delete
    restoreDish(id: ID!): Dish @can(ability: "restore") @restore
    forceDeleteCategoryDish(id: ID!): Dish @can(ability: "forceDelete") @forceDelete

    createMenu(
        dish_id: ID!
        price: Int!
        actual_at: Date!
    ): Menu! @can(ability: "create") @create
    updateMenu(
        id: ID!
        dish_id: ID
        price: Int
        actual_at: Date
    ): Menu @can(ability: "update") @update
    upsertMenu(
        id: ID!
        dish_id: ID!
        price: Int!
        actual_at: Date!
    ): Menu @can(ability: "upsert") @upsert
    deleteMenu(id: ID!): Menu @can(ability: "delete") @delete
    restoreMenu(id: ID!): Menu @can(ability: "restore") @restore
    forceDeleteCategoryMenu(id: ID!): Menu @can(ability: "forceDelete") @forceDelete

    createCart(
        user_id: ID!
        menu_id: ID!
        price: Int!
        count: Int!
    ): Cart! @can(ability: "create") @create
    updateCart(
        id: ID!
        user_id: ID
        menu_id: ID
        price: Int
        count: Int
    ): Cart @can(ability: "update") @update
    upsertCart(
        id: ID!
        user_id: ID!
        menu_id: ID!
        price: Int!
        count: Int!
    ): Cart @can(ability: "upsert") @upsert
    deleteCart(id: ID!): Cart @can(ability: "forceDelete") @forceDelete

    createOrder(
        customer_id: ID!
        recipient_id: ID
    ): Order! @can(ability: "create") @create
    updateOrder(
        id: ID!
        customer_id: ID
        recipient_id: ID
    ): Order @can(ability: "update") @update
    upsertOrder(
        id: ID!
        customer_id: ID!
        recipient_id: ID!
    ): Order @can(ability: "upsert") @upsert
    deleteOrder(id: ID!): Order @can(ability: "delete") @delete
    restoreOrder(id: ID!): Order @can(ability: "restore") @restore
    forceDeleteCategoryOrder(id: ID!): Order @can(ability: "forceDelete") @forceDelete

    createOrderItem(
        order_id: ID!
        dish_id: ID!
        price: Int!
        count: Int!
    ): OrderItem! @can(ability: "create") @create
    updateOrderItem(
        id: ID!
        order_id: ID
        dish_id: ID
        price: Int
        count: Int
    ): OrderItem @can(ability: "update") @update
    upsertOrderItem(
        id: ID!
        order_id: ID
        dish_id: ID
        price: Int
        count: Int
    ): OrderItem @can(ability: "upsert") @upsert
    deleteOrderItem(id: ID!): OrderItem @can(ability: "delete") @delete
    restoreOrderItem(id: ID!): OrderItem @can(ability: "restore") @restore
    forceDeleteCategoryOrderItem(id: ID!): OrderItem @can(ability: "forceDelete") @forceDelete
}

type AccessToken {
    token: String!
}

input LoginInput {
    email: String! @rules(apply: ["email"])
    password: String!
}

type LogoutResponse {
    status: LogoutStatus!
    message: String!
}

enum LogoutStatus {
    """TOKEN_REVOKED"""
    TOKEN_REVOKED
}

extend type Mutation {
    login(input: LoginInput @spread): AccessToken!
    @field(resolver: "App\\GraphQL\\Mutations\\Login")
    logout: LogoutResponse! @guard
    @field(resolver: "App\\GraphQL\\Mutations\\Logout")
#    register(input: RegisterInput @spread): RegisterResponse!
#    @field(resolver: "DanielDeWit\\LighthouseSanctum\\GraphQL\\Mutations\\Register")
#    verifyEmail(input: VerifyEmailInput! @spread): EmailVerificationResponse!
#    @field(resolver: "DanielDeWit\\LighthouseSanctum\\GraphQL\\Mutations\\VerifyEmail")
#    resendEmailVerification(input: ResendEmailVerificationInput! @spread): ResendEmailVerificationResponse!
#    @field(resolver: "DanielDeWit\\LighthouseSanctum\\GraphQL\\Mutations\\ResendEmailVerification")
#    forgotPassword(input: ForgotPasswordInput! @spread): ForgotPasswordResponse!
#    @field(resolver: "DanielDeWit\\LighthouseSanctum\\GraphQL\\Mutations\\ForgotPassword")
#    resetPassword(input: ResetPasswordInput! @spread): ResetPasswordResponse!
#    @field(resolver: "DanielDeWit\\LighthouseSanctum\\GraphQL\\Mutations\\ResetPassword")
#    updatePassword(input: UpdatePasswordInput! @spread): UpdatePasswordResponse! @guard
#    @field(resolver: "DanielDeWit\\LighthouseSanctum\\GraphQL\\Mutations\\UpdatePassword")
}